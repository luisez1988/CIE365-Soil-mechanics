<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Octahedral Alumina Structure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            color: white;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">
        <strong>Al(OH)₆³⁻ Octahedron</strong><br>
        <span style="color: #9370DB;">Purple</span>: Aluminum (Al)<br>
        <span style="color: #FF4444;">Red</span>: Hydroxyl (OH)
    </div>
    <div id="controls">
        <button id="resetBtn">Reset View</button>
        <button id="toggleAlBondsBtn">Toggle Al-O Bonds</button>
        <button id="toggleEdgesBtn">Toggle Octahedral Edges</button>
        <button id="toggleLabelsBtn">Toggle Labels</button>
        <button id="rotateBtn">Auto Rotate</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFFFFF);
        
        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(
            75,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-10, -10, -10);
        scene.add(directionalLight2);
        
        // Materials
        const aluminumMaterial = new THREE.MeshPhongMaterial({
            color: 0x9370DB,
            shininess: 100,
            specular: 0x111111
        });
        
        const oxygenMaterial = new THREE.MeshPhongMaterial({
            color: 0xFF4444,
            shininess: 80,
            specular: 0x111111
        });
        
        const bondMaterial = new THREE.MeshPhongMaterial({
            color: 0x228B22,
            shininess: 50
        });
        
        // Create a group to hold everything - OPTIMIZED APPROACH!
        const moleculeGroup = new THREE.Group();
        scene.add(moleculeGroup);
        
        const alBonds = new THREE.Group();
        const octahedralEdges = new THREE.Group();
        
        // Aluminum atom (center)
        const alGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        const alAtom = new THREE.Mesh(alGeometry, aluminumMaterial);
        alAtom.position.set(0, 0, 0);
        moleculeGroup.add(alAtom);
        
        // Hydroxyl ions (vertices of octahedron)
        const oGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        // Octahedral positions - 6 vertices
        const scale = 2.5;
        const oPositions = [
            [scale, 0, 0],      // +X
            [-scale, 0, 0],     // -X
            [0, scale, 0],      // +Y
            [0, -scale, 0],     // -Y
            [0, 0, scale],      // +Z
            [0, 0, -scale]      // -Z
        ];
        
        oPositions.forEach((pos, index) => {
            const oAtom = new THREE.Mesh(oGeometry, oxygenMaterial);
            oAtom.position.set(pos[0], pos[1], pos[2]);
            moleculeGroup.add(oAtom);
            
            // Create Al-O bond (cylinder)
            const direction = new THREE.Vector3(pos[0], pos[1], pos[2]);
            const length = direction.length();
            const bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, length, 8);
            const bond = new THREE.Mesh(bondGeometry, bondMaterial);
            
            bond.position.copy(direction).multiplyScalar(0.5);
            const axis = new THREE.Vector3(0, 1, 0);
            bond.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
            
            alBonds.add(bond);
        });
        
        moleculeGroup.add(alBonds);
        
        // Create edges between oxygen atoms for octahedral shape
        // An octahedron has 12 edges connecting the 6 vertices
        const edges = [
            // Top pyramid (vertex 2 = +Y connects to 4 equatorial)
            [2, 0], [2, 4], [2, 1], [2, 5],
            // Bottom pyramid (vertex 3 = -Y connects to 4 equatorial)
            [3, 0], [3, 4], [3, 1], [3, 5],
            // Equatorial square
            [0, 4], [4, 1], [1, 5], [5, 0]
        ];
        
        const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0x666666,
            linewidth: 1,
            transparent: true,
            opacity: 0.3
        });
        
        edges.forEach(([i, j]) => {
            const edgeGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(oPositions[i][0], oPositions[i][1], oPositions[i][2]),
                new THREE.Vector3(oPositions[j][0], oPositions[j][1], oPositions[j][2])
            ]);
            const edge = new THREE.Line(edgeGeometry, edgeMaterial);
            octahedralEdges.add(edge);
        });
        
        moleculeGroup.add(octahedralEdges);
        
        // Camera position
        camera.position.z = 8;
        camera.position.y = 2;
        camera.lookAt(0, 0, 0);
        
        // Mouse controls - ROTATE THE GROUP, NOT RECALCULATE POSITIONS!
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = false;
        
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                moleculeGroup.rotation.y += deltaX * 0.01;
                moleculeGroup.rotation.x += deltaY * 0.01;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                autoRotate = false;
            }
        });
        
        container.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(3, Math.min(15, camera.position.z));
        });
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        container.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            moleculeGroup.rotation.y += deltaX * 0.01;
            moleculeGroup.rotation.x += deltaY * 0.01;
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            autoRotate = false;
        });
        
        // Button controls
        document.getElementById('resetBtn').addEventListener('click', () => {
            moleculeGroup.rotation.set(0, 0, 0);
            camera.position.z = 8;
            camera.position.y = 2;
            autoRotate = false;
        });
        
        document.getElementById('toggleAlBondsBtn').addEventListener('click', () => {
            alBonds.visible = !alBonds.visible;
        });
        
        document.getElementById('toggleEdgesBtn').addEventListener('click', () => {
            octahedralEdges.visible = !octahedralEdges.visible;
        });
        
        document.getElementById('toggleLabelsBtn').addEventListener('click', () => {
            const info = document.getElementById('info');
            info.style.display = info.style.display === 'none' ? 'block' : 'none';
        });
        
        document.getElementById('rotateBtn').addEventListener('click', () => {
            autoRotate = !autoRotate;
            document.getElementById('rotateBtn').textContent = 
                autoRotate ? 'Stop Rotation' : 'Auto Rotate';
        });
        
        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // OPTIMIZED Animation loop - NO recalculation, just simple rotation!
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                moleculeGroup.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
